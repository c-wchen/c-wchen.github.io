(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{421:function(v,_,t){"use strict";t.r(_);var e=t(13),a=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[v._v("在CPU有L1、L2、L3三级缓存，当应用程序并发使用共享变量时，会加载变量到缓存中，如何保证缓存中的变量时有效的，这需要引入一些"),t("code",[v._v("缓存一致性")]),v._v("机制")]),v._v(" "),t("h2",{attrs:{id:"mesi缓存一致性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mesi缓存一致性"}},[v._v("#")]),v._v(" MESI缓存一致性")]),v._v(" "),t("p",[t("code",[v._v("IMSI")]),v._v("表示4中缓存行状态，由4个状态的首字母拼凑而成。")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("Modify")]),v._v(" "),t("blockquote",[t("p",[v._v("表示缓存行数据被修改了，并且没有更新至主内存。处于这一状态的数据，只在本CPU中有缓存数据，而其他CPU中没有。简单的可理解为"),t("strong",[v._v("缓存行数据独占被修改且未同步")])])])]),v._v(" "),t("li",[t("p",[v._v("Exclusive")]),v._v(" "),t("blockquote",[t("p",[v._v("表示缓存行数据是独占的。处于这一状态的数据，只有在本CPU中有缓存，其它CPU中没有缓存该数据，且其数据没有修改与主内存中一致。简单的可理解为"),t("strong",[v._v("缓存行数据独占且未被修改")])])])]),v._v(" "),t("li",[t("p",[v._v("Share")]),v._v(" "),t("blockquote",[t("p",[v._v("表示缓存行数据是共享的。处于这一状态的数据在多个CPU中都有缓存，且与内存一致")])])]),v._v(" "),t("li",[t("p",[v._v("Invalid")]),v._v(" "),t("blockquote",[t("p",[v._v("表示缓存行数据是无效的。本CPU中的这份缓存已经无效。")])])])]),v._v(" "),t("h3",{attrs:{id:"保证缓存一致性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#保证缓存一致性"}},[v._v("#")]),v._v(" 保证缓存一致性")]),v._v(" "),t("p",[v._v("MESI协议对不同的状态增了不同的"),t("strong",[v._v("监听任务")]),v._v("，监听任务的规则如下")]),v._v(" "),t("ul",[t("li",[v._v("处于"),t("code",[v._v("M")]),v._v("状态的缓存行，必须时刻监听所有"),t("code",[v._v("试图读取")]),v._v("该缓存行对应的主存地址的操作，如果监听到，则必须在此操作执行前把其缓存行中的"),t("code",[v._v("数据写回主内存")])]),v._v(" "),t("li",[v._v("处于"),t("code",[v._v("S")]),v._v("状态的缓存行，必须时刻监听使该缓存行"),t("code",[v._v("无效")]),v._v("或者"),t("code",[v._v("独享")]),v._v("该缓存行的请求，如果监听到，则必须把其缓存行状态设置为"),t("code",[v._v("I")]),v._v("。")]),v._v(" "),t("li",[v._v("处于"),t("code",[v._v("E")]),v._v("状态的缓存行，必须时刻监听其他试图"),t("code",[v._v("读取")]),v._v("该缓存行对应的主存地址的操作，如果监听到，则必须把其缓存行状态设置为S。")])]),v._v(" "),t("h3",{attrs:{id:"imsi存在的问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#imsi存在的问题"}},[v._v("#")]),v._v(" IMSI存在的问题")]),v._v(" "),t("p",[v._v("在JMM中使用了IMSI为什么还要添加volatile保证可见性，或者只有添加voltaile之后才能触发IMSI")]),v._v(" "),t("ol",[t("li",[v._v("多核情况下，所有的cpu操作都会涉及缓存一致性的校验，只不过该协议是弱一致性，不能保证一个线程修改变量后，其他线程立马可见，也就是说虽然其他CPU状态已经置为无效，但是当前"),t("strong",[v._v("CPU可能将数据修改之后又去做其他事情，没有来得及将修改后的变量刷新回主存")]),v._v("，而如果此时其他CPU需要使用该变量，则又会从主存中读取到旧的值。"),t("strong",[v._v("而volatile则可以保证可见性，即立即刷新回主存")]),v._v("，修改操作和写回操作必须是一个原子操作；")]),v._v(" "),t("li",[v._v("正常情况下，系统操作并不会进行缓存一致性的校验，只有变量被volatile修饰了，该变量所在的缓存行才被赋予缓存一致性的校验功能。")])]),v._v(" "),t("h2",{attrs:{id:"内存屏障"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存屏障"}},[v._v("#")]),v._v(" 内存屏障")]),v._v(" "),t("p",[v._v("内存屏障")]),v._v(" "),t("ol",[t("li",[v._v("防止指令之间的重排序")]),v._v(" "),t("li",[v._v("保证数据的可见性")])]),v._v(" "),t("h2",{attrs:{id:"参考文献"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考文献"}},[v._v("#")]),v._v(" 参考文献")]),v._v(" "),t("p",[t("a",{attrs:{href:"https://albk.tech/%E8%81%8A%E8%81%8A%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("聊聊缓存一致性协议 | BK的网络日志 (albk.tech)"),t("OutboundLink")],1)])])}),[],!1,null,null,null);_.default=a.exports}}]);