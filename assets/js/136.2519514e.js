(window.webpackJsonp=window.webpackJsonp||[]).push([[136],{465:function(v,_,a){"use strict";a.r(_);var e=a(13),s=Object(e.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"arm处理器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#arm处理器"}},[v._v("#")]),v._v(" ARM处理器")]),v._v(" "),a("p",[v._v("ARM指令集RISC（精简指令集）区别于X86 CISC（复杂指令集），采用更少的指令来完成更多个工作，在性能有所弱势，但是在功耗方面处于领先地位，所以ARM CPU一般应用于移动设备。")]),v._v(" "),a("h2",{attrs:{id:"寄存器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#寄存器"}},[v._v("#")]),v._v(" 寄存器")]),v._v(" "),a("p",[v._v("R0~R30 x访问64位 w访问32位")]),v._v(" "),a("p",[v._v("r29 = fp (frame pointer)\nr30 = lr (link register): 调用者下一行指令，返回时使用")]),v._v(" "),a("p",[v._v("x31 = sp (用 sp/wsp 访问)\npc (program conter)")]),v._v(" "),a("p",[v._v("v0~v31 向量寄存器(浮点型寄存器) 128 位，可以通过 "),a("code",[v._v("Bn(8) Hn(16) Sn(32) Dn(64) Qn(128)")]),v._v(" 访问")]),v._v(" "),a("p",[v._v("SPRs 状态寄存器 "),a("code",[v._v("The Current Program Status Register (CPSR)")]),v._v(" "),a("code",[v._v("The Saved Program Status Registers (SPSRs)")]),v._v(" "),a("code",[v._v("FPSR")]),v._v("浮点状态")]),v._v(" "),a("h3",{attrs:{id:"栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[v._v("#")]),v._v(" 栈")]),v._v(" "),a("p",[v._v("栈从"),a("strong",[v._v("高地址往低地址")]),v._v("生长，arm64 开始堆栈的操作是 16 字节对齐的，即拉伸栈空间一定是16的倍数，换句话说就是 "),a("code",[v._v("0x10")]),v._v(" 最小，最后一位一定是 0")]),v._v(" "),a("ul",[a("li",[a("code",[v._v("fp")]),v._v(" 指向当前 frame 的栈底，高地址")]),v._v(" "),a("li",[a("code",[v._v("sp")]),v._v(" 指向栈顶，低地址")])]),v._v(" "),a("h3",{attrs:{id:"传参"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#传参"}},[v._v("#")]),v._v(" 传参")]),v._v(" "),a("ul",[a("li",[v._v("一般 arm64 上 x0 - x7 分别存放方法的前 8 个参数")]),v._v(" "),a("li",[v._v("超过的 8 个的，多余的放在栈上")]),v._v(" "),a("li",[v._v("返回值放在 x0 上")]),v._v(" "),a("li",[v._v("返回值是一个较大的数据结构时，结果糊存在 x8 执行的地址上")])]),v._v(" "),a("p",[v._v("##　指令计算")]),v._v(" "),a("h3",{attrs:{id:"_1-算数运算"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-算数运算"}},[v._v("#")]),v._v(" 1. 算数运算")]),v._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[v._v("add x0, x1, x2  ; x0 = x1 + x2\nsub x0, x1, x2  ; x0 = x1 - x2\ncmp x11, #4     ; 相当于 subs xzr, x11, #4 (subs 有符号减法，xzr 零寄存器)\n                ; 如果 x11 - 4 == 0，那么状态寄存器的 NZCV.Z = 1\n                ; 如果 x11 - 4 < 0, 那么 NZCV.N = 1\n")])])]),a("blockquote",[a("p",[a("code",[v._v("NZCV")]),v._v(" 是状态寄存器的几个状态值\n"),a("code",[v._v("N, negative condition flag")]),v._v(" 运算结果为负\n"),a("code",[v._v("Z, zero condition flag")]),v._v(" 运算结果为 0\n"),a("code",[v._v("C, carry condition flag")]),v._v(" 无符号运算有溢出时， C = 1\n"),a("code",[v._v("V, oVerflow condition flag")]),v._v(" 有符号运算")])]),v._v(" "),a("h3",{attrs:{id:"_2-逻辑运算"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-逻辑运算"}},[v._v("#")]),v._v(" 2. 逻辑运算")]),v._v(" "),a("ul",[a("li",[a("code",[v._v("LSL/lsl")]),v._v(" 逻辑左移 "),a("code",[v._v("LSR/lsr")]),v._v(" 逻辑右移")]),v._v(" "),a("li",[a("code",[v._v("ASR/asr")]),v._v(" 算术右移 "),a("code",[v._v("ROR/ror")]),v._v(" 循环右移")]),v._v(" "),a("li",[a("code",[v._v("AND/and")]),v._v(" 与 "),a("code",[v._v("ORR/orr")]),v._v(" 或 "),a("code",[v._v("EOR/eor")]),v._v(" 异或")])]),v._v(" "),a("p",[v._v("逻辑位移可以与算术运算一起用，如")]),v._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[v._v("add x14, x4, x27, lsl #1  ; x14 = x4 + (x27 << 1)\n")])])]),a("h3",{attrs:{id:"_3-寻址"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-寻址"}},[v._v("#")]),v._v(" 3. 寻址")]),v._v(" "),a("ul",[a("li",[v._v("L 开头为取，如 "),a("code",[v._v("ldr")]),v._v("，"),a("code",[v._v("ldp")])]),v._v(" "),a("li",[v._v("S 开头为存，如 "),a("code",[v._v("str")]),v._v("，"),a("code",[v._v("stp")])])]),v._v(" "),a("blockquote",[a("p",[a("code",[v._v("ldr")]),v._v(" 将内存数据存到寄存器中\n"),a("code",[v._v("ldp")]),v._v(" 一个变体，可以同时读写两个寄存器")])]),v._v(" "),a("p",[v._v("例如：")]),v._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[v._v("ldr x0, [x1]                ; 从 x1 指向的地址中区一个 64 为数据存入 x0\nldp x1, x2, [x10, #10]      ; 从 x10+10 指向的地址中取 2 个 64 位的数，分别存入 x1, x2 低地址的存入 x1\nstr x5, [sp, #24]           ; 将 x5 内容存入 sp+24 所指向的内存地址上\nstp x29, x30, [sp, #-16]!   ; 将 x29, x30 存到 sp-16 所指向的内存地址上，x29 在低地址，同时 sp = sp - 16 (感叹号的意思)\nldp x29, x30, [sp], #16     ; 从 sp 指向的内存地址中区两个 64 位数据存入 x29, x30 中，并且 sp += 16\n")])])]),a("p",[v._v("寻址操作示例：")]),v._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[v._v("[x10, #0x10]      // signed offset。 意思是从 x10 + 0x10的地址取值\n[sp, #-16]!       // pre-index。  意思是从 sp-16地址取值，取值完后在把 sp-16  writeback 回 sp\n[sp], #16         // post-index。 意思是从 sp 地址取值，取值完后在把 sp+16 writeback 回 sp\n")])])]),a("h3",{attrs:{id:"_4-函数调用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-函数调用"}},[v._v("#")]),v._v(" 4. 函数调用")]),v._v(" "),a("p",[v._v("跳转分为有返回跳转 "),a("code",[v._v("bl")]),v._v(" 和无返回跳转 "),a("code",[v._v("b")]),v._v("，有返回会存 "),a("code",[v._v("lr")]),v._v("。")]),v._v(" "),a("blockquote",[a("p",[v._v("1.存了LR也就意味着可以返回到本方法继续执行。一般用于不同方法直接的调用\n2.B相关的跳转没有 "),a("code",[v._v("LR")]),v._v("，一般是本方法内的跳转，如"),a("code",[v._v("while")]),v._v("循环，"),a("code",[v._v("if else")]),v._v("等。")])]),v._v(" "),a("p",[v._v("跳转可以依赖运算产生的标志位，即 "),a("code",[v._v("NZCV")]),v._v(" 有一下可选情况：")]),v._v(" "),a("p",[v._v("如")]),v._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[v._v("cmp x2, 0\nb.ne addr\n\n0x1000d4ab0 bl testFuncA;  // 跳转方法，这个时候 lr 设置为 0x1000d4ab4\n0x1000d4ab4 orr x8, xzr, #0x1f00000000 // testFuncA执行完之后跳回lr就周到了这一行\n")])])]),a("h2",{attrs:{id:"参考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[v._v("#")]),v._v(" 参考")]),v._v(" "),a("p",[a("a",{attrs:{href:"https://bluesjiang.github.io/ARM-%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/",target:"_blank",rel:"noopener noreferrer"}},[v._v("ARM 汇编笔记 "),a("OutboundLink")],1)])])}),[],!1,null,null,null);_.default=s.exports}}]);