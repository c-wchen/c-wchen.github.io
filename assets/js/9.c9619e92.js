(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{275:function(a,t,e){a.exports=e.p+"assets/img/image-20200819105127262.3398afe2.png"},276:function(a,t,e){a.exports=e.p+"assets/img/image-20200819105156141.b209d398.png"},277:function(a,t,e){a.exports=e.p+"assets/img/image-20200819105223309.54b6fdee.png"},278:function(a,t,e){a.exports=e.p+"assets/img/image-20200819105250840.bc01f163.png"},425:function(a,t,e){"use strict";e.r(t);var r=e(13),v=Object(r.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("p",[r("strong",[a._v("Java类加载器")]),a._v("（英语：Java Classloader）是"),r("a",{attrs:{href:"https://zh.wikipedia.org/wiki/Java%E5%B9%B3%E8%87%BA#Java_%E5%9F%B7%E8%A1%8C%E7%92%B0%E5%A2%83",target:"_blank",rel:"noopener noreferrer"}},[a._v("Java运行时环境"),r("OutboundLink")],1),a._v("（Java Runtime Environment）的一个部件，负责"),r("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E5%8B%95%E6%85%8B%E8%A3%9D%E8%BC%89",target:"_blank",rel:"noopener noreferrer"}},[a._v("动态加载"),r("OutboundLink")],1),r("a",{attrs:{href:"https://zh.wikipedia.org/w/index.php?title=Java%E7%B1%BB&action=edit&redlink=1",target:"_blank",rel:"noopener noreferrer"}},[a._v("Java类"),r("OutboundLink")],1),a._v("到"),r("a",{attrs:{href:"https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA",target:"_blank",rel:"noopener noreferrer"}},[a._v("Java虚拟机"),r("OutboundLink")],1),a._v("的内存空间中。["),r("a",{attrs:{href:"https://zh.wikipedia.org/wiki/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8#cite_note-1",target:"_blank",rel:"noopener noreferrer"}},[a._v("1]"),r("OutboundLink")],1),a._v("类通常是"),r("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B%E6%A8%A1%E5%BC%8F",target:"_blank",rel:"noopener noreferrer"}},[a._v("按需加载"),r("OutboundLink")],1),a._v("，即第一次使用该类时才加载。由于有了类加载器，Java运行时系统不需要知道文件与文件系统 --"),r("a",{attrs:{href:"%5Bhttps://zh.wikipedia.org/wiki/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%5D(https://zh.wikipedia.org/wiki/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8)"}},[a._v("维基百科")])]),a._v(" "),r("h3",{attrs:{id:"类加载器的种类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#类加载器的种类"}},[a._v("#")]),a._v(" 类加载器的种类")]),a._v(" "),r("ol",[r("li",[r("p",[a._v("虚拟机自带加载器")])]),a._v(" "),r("li",[r("p",[a._v("启动类加载器（bootstrap）")]),a._v(" "),r("p",[a._v("是用本地代码实现的类装入器，它负责将 "),r("code",[a._v("<Java_Runtime_Home>/lib")]),a._v("下面的类库加载到内存中（比如"),r("code",[a._v("rt.jar")]),a._v("）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作")])]),a._v(" "),r("li",[r("p",[a._v("扩展类加载器（extension）")]),a._v(" "),r("p",[a._v("是由 Sun 的 "),r("code",[a._v("ExtClassLoader（sun.misc.Launcher$ExtClassLoader）")]),a._v("实现的。它负责将"),r("code",[a._v("< Java_Runtime_Home >/lib/ext")]),a._v("或者由系统变量 "),r("code",[a._v("java.ext.dir")]),a._v("指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器")])]),a._v(" "),r("li",[r("p",[a._v("应用程序加载器（application）")]),a._v(" "),r("p",[a._v("由 Sun 的 "),r("code",[a._v("AppClassLoader（sun.misc.Launcher$AppClassLoader）")]),a._v("实现的。它负责将系统类路径（"),r("code",[a._v("CLASSPATH")]),a._v("）中指定的类库加载到内存中。开发者可以直接使用系统类加载器")])]),a._v(" "),r("li",[r("p",[a._v("自定义加载器")])])]),a._v(" "),r("h3",{attrs:{id:"双亲委派机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#双亲委派机制"}},[a._v("#")]),a._v(" 双亲委派机制")]),a._v(" "),r("p",[a._v("某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，"),r("strong",[a._v("依次递归")]),a._v("，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。")]),a._v(" "),r("p",[a._v("双亲委派机制过程")]),a._v(" "),r("p",[a._v("使用双亲委派模型的好处在于"),r("strong",[a._v("Java类随着它的类加载器一起具备了一种带有优先级的层次关系")]),a._v("。例如类java.lang.Object，它存在在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的Bootstrap ClassLoader进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，那系统中将会出现多个不同的Object类，程序将混乱。因此，如果开发者尝试编写一个与rt.jar类库中重名的Java类，可以正常编译，但是永远无法被加载运行。")]),a._v(" "),r("h3",{attrs:{id:"沙箱安全机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#沙箱安全机制"}},[a._v("#")]),a._v(" 沙箱安全机制")]),a._v(" "),r("p",[a._v("在Java中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的Java实现中，安全依赖于沙箱 (Sandbox) 机制。如下图所示")]),a._v(" "),r("p",[r("img",{attrs:{src:e(275),alt:"image-20200819105127262"}})]),a._v(" "),r("p",[a._v("但如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。因此在后续的 Java1.1 版本中，针对安全机制做了改进，增加了安全策略，允许用户指定代码对本地资源的访问权限。如下图所示")]),a._v(" "),r("p",[r("img",{attrs:{src:e(276),alt:"image-20200819105156141"}})]),a._v(" "),r("p",[a._v("在 Java1.2 版本中，再次改进了安全机制，增加了代码签名。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图所示")]),a._v(" "),r("p",[r("img",{attrs:{src:e(277),alt:"image-20200819105223309"}})]),a._v(" "),r("p",[a._v("当前最新的安全机制实现，则引入了域 (Domain) 的概念。虚拟机会把所有代码加载到不同的系统域和应用域，系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域 (Protected Domain)，对应不一样的权限 (Permission)。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示")]),a._v(" "),r("p",[r("img",{attrs:{src:e(278),alt:"image-20200819105250840"}})]),a._v(" "),r("h3",{attrs:{id:"本地方法接口-jni"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#本地方法接口-jni"}},[a._v("#")]),a._v(" 本地方法接口 JNI")]),a._v(" "),r("p",[a._v("扩展java的使用， 融合不同编程语言为java调用， 最初设计只是为了调用C和C++")]),a._v(" "),r("p",[a._v("native关键字")]),a._v(" "),r("p",[a._v("凡是使用native关键字的方法， 会进入本地方法栈 -> JNI（java本地方法接口） -> 本地方法库")]),a._v(" "),r("h3",{attrs:{id:"参考链接"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考链接"}},[a._v("#")]),a._v(" 参考链接")]),a._v(" "),r("p",[r("a",{attrs:{href:"https://www.cnblogs.com/MyStringIsNotNull/p/8268351.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("java中的安全模型(沙箱机制)"),r("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=v.exports}}]);