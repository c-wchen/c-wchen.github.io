(window.webpackJsonp=window.webpackJsonp||[]).push([[98],{417:function(t,e,a){"use strict";a.r(e);var l=a(13),s=Object(l.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("select、poll、epoll都是实现IO多路复用的的机制，通过该机制一个进程可以监视多个描述符，一旦描述符就绪（读写就绪）能够通知程序进行读写操作, epoll是linux所特有，而select是POSIX所规定，一般操作系统均有实现。")]),t._v(" "),a("h2",{attrs:{id:"select"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#select"}},[t._v("#")]),t._v(" select")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("遍历所有连接"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("是否有数据"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 处理逻辑")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("select本质是通过设置或检查存放fd标志位的数据结构来进行下一步处理。缺点是：")]),t._v(" "),a("ol",[a("li",[t._v("单个进程可监视的fd数量被限制，即能监听端口的大小有限。一般来说和系统内存有关，具体数目可以cat /proc/sys/fs/file-max察看。32位默认是1024个，64位默认为2048个")]),t._v(" "),a("li",[t._v("对socket进行扫描时是线性扫描，即采用轮询方法，效率低。当套接字比较多的时候，每次select()都要遍历FD_SETSIZE个socket来完成调度，不管socket是否活跃都遍历一遍。会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，就避免了轮询，这正是epoll与kqueue做的")]),t._v(" "),a("li",[t._v("需要维护一个用来存放大量fd的数据结构，会使得用户空间和内核空间在传递该结构时复制开销大")])]),t._v(" "),a("h2",{attrs:{id:"poll"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#poll"}},[t._v("#")]),t._v(" poll")]),t._v(" "),a("p",[t._v("poll本质和select相同，将用户传入的数据拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或主动超时，被唤醒后又要再次遍历fd。它没有最大连接数的限制，原因是它是基于链表来存储的，但缺点是：")]),t._v(" "),a("ol",[a("li",[t._v("大量的fd的数组被整体复制到用户态和内核空间之间，不管有无意义。")]),t._v(" "),a("li",[t._v("poll还有一个特点“水平触发”，如果报告了fd后，没有被处理，那么下次poll时再次报告该ffd。")])]),t._v(" "),a("h2",{attrs:{id:"epoll"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#epoll"}},[t._v("#")]),t._v(" epoll")]),t._v(" "),a("p",[t._v("epoll支持水平触发和边缘触发，最大特点在于边缘触发，只告诉哪些fd刚刚变为就绪态，并且只通知一次。还有一特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一量该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。epoll的优点：")]),t._v(" "),a("ol",[a("li",[t._v("没有最大并发连接的限制。")]),t._v(" "),a("li",[t._v("效率提升，只有活跃可用的FD才会调用callback函数。")]),t._v(" "),a("li",[t._v("内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递。")])]),t._v(" "),a("h3",{attrs:{id:"select、poll、epoll区别总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#select、poll、epoll区别总结"}},[t._v("#")]),t._v(" select、poll、epoll区别总结：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}}),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("支持一个进程打开连接数")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("IO效率")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("消息传递方式")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("select")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("32位机器1024个，64位2048个")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("IO效率低")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("内核需要将消息传递到用户空间，都需要内核拷贝动作")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("poll")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("无限制，原因基于链表存储")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("IO效率低")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("内核需要将消息传递到用户空间，都需要内核拷贝动作")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("epoll")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("有上限，但很大，2G内存20W左右")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("只有活跃的socket才调用callback，IO效率高")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("通过内核与用户空间共享一块内存来实现")])])])]),t._v(" "),a("h2",{attrs:{id:"参考链接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考链接"}},[t._v("#")]),t._v(" 参考链接")]),t._v(" "),a("p",[t._v("https://juejin.im/post/6844903782094995470")])])}),[],!1,null,null,null);e.default=s.exports}}]);