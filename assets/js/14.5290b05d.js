(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{279:function(a,t,n){a.exports=n.p+"assets/img/165e7947ce93f969.0c3d18d5.jpg"},280:function(a,t,n){a.exports=n.p+"assets/img/165e7947cef87a28.156f379d.jpg"},281:function(a,t,n){a.exports=n.p+"assets/img/165e7947cf29003b.7556450a.jpg"},428:function(a,t,n){"use strict";n.r(t);var s=n(13),e=Object(s.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"javac"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#javac"}},[a._v("#")]),a._v(" Javac")]),a._v(" "),s("p",[a._v("通常，一个java文件会通过编译器编译成字节码文件.class，再又java虚拟机JVM翻译成计算机可执行的文件。")]),a._v(" "),s("p",[a._v("我们所知道的java语言有它自己的语法规范，同样的JVM也有它的语法规范，如何让java的语法规则去适应语法解析规则，这就是javac的作用，简而言之，javac的作用就是将java源代码转化成class字节码文件。")]),a._v(" "),s("h1",{attrs:{id:"javac编译器基本结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#javac编译器基本结构"}},[a._v("#")]),a._v(" Javac编译器基本结构")]),a._v(" "),s("h2",{attrs:{id:"编译步骤"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#编译步骤"}},[a._v("#")]),a._v(" 编译步骤")]),a._v(" "),s("p",[s("img",{attrs:{src:n(279),alt:"image"}})]),a._v(" "),s("h3",{attrs:{id:"_1-词法分析器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-词法分析器"}},[a._v("#")]),a._v(" 1. 词法分析器：")]),a._v(" "),s("h4",{attrs:{id:"_1-1作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1作用"}},[a._v("#")]),a._v(" 1.1作用：")]),a._v(" "),s("p",[a._v("将源码转化为Token流")]),a._v(" "),s("h4",{attrs:{id:"_1-2流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2流程"}},[a._v("#")]),a._v(" 1.2流程")]),a._v(" "),s("p",[a._v("读取源代码，从源文件的一个字符开始，按照java语法规范依次找出package，import，类定义，属性，方法定义等，最后构建出一个抽象语法树")]),a._v(" "),s("h4",{attrs:{id:"_1-3举例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-3举例"}},[a._v("#")]),a._v(" 1.3举例")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("package compile;\n\n/**\n * 词法解析器\n */\n public class Cifa{\n     int a;\n     int c = a + 1;\n }\n复制代码\n")])])]),s("p",[a._v("转化为Token流：")]),a._v(" "),s("p",[s("img",{attrs:{src:n(280),alt:"image"}})]),a._v(" "),s("h4",{attrs:{id:"_1-4源码分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-4源码分析"}},[a._v("#")]),a._v(" 1.4源码分析")]),a._v(" "),s("ul",[s("li",[a._v("com.sun.tools.javac.parser.JavacParser  规定哪些词符合Java语言规范，具体读取和归类不同词法的操作由scanner完成")]),a._v(" "),s("li",[a._v("com.sun.tools.javac.parser.Scanner  负责逐个读取源代码的单个字符,然后解析符合Java语言规范的Token序列，调用一次nextToken()都构造一个Token")]),a._v(" "),s("li",[a._v("com.sun.tools.javac.parser.Tokens$TokenKind  里面包含了所有token的类型，譬如BOOLEAN,BREAK,BYTE,CASE。")]),a._v(" "),s("li",[a._v("com.sun.tools.javac.util.Names  用来存储和表示解析后的词法，每个字符集合都会是一个Name对象，所有的对象都存储在Name.Table这个内部类中。")]),a._v(" "),s("li",[a._v("com.sun.tools.javac.parser.KeyWords  负责将字符集合对应到token集合中，如，package zxy.demo.com; Token.PACKAGE = package， Token.IDENTIFIER = zxy.demo.com,(这部分又分为读取第一个token,为zxy，判断下一个token是否为“.”，是的话接着读取下一个Token.IDENTIFIER类型的token，反复直至下一个token不是”.”,也就是说下一个不是Token.IDENIFIER类型的token，Token.SEMI = ；即这个TIDENTIFIER类型的token的Name读完），KeyWords类负责此任务。")])]),a._v(" "),s("h4",{attrs:{id:"_1-5问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-5问题"}},[a._v("#")]),a._v(" 1.5问题")]),a._v(" "),s("h5",{attrs:{id:"javac是如何分辨这一个个token呢-例如它时如何直到package是关键词而不是自定义变量呢"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#javac是如何分辨这一个个token呢-例如它时如何直到package是关键词而不是自定义变量呢"}},[a._v("#")]),a._v(" Javac是如何分辨这一个个Token呢？例如它时如何直到package是关键词而不是自定义变量呢？")]),a._v(" "),s("p",[a._v("Javac在进行此法分析时会由JavacParser根据Java语言规范来控制什么顺序，地方会出现什么Token，例如package就只能在文件的最开头出现")]),a._v(" "),s("h5",{attrs:{id:"javac怎样确定哪些字符组合在一起就是一个token呢-它如何从一串字符流中划分出token来"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#javac怎样确定哪些字符组合在一起就是一个token呢-它如何从一串字符流中划分出token来"}},[a._v("#")]),a._v(" Javac怎样确定哪些字符组合在一起就是一个Token呢？它如何从一串字符流中划分出Token来？")]),a._v(" "),s("p",[a._v("对于关键字，主要由关键字的语法规则，例如package就是若一个字符串package是连续的，那么他就是关键字")]),a._v(" "),s("p",[a._v("对于自定义变量名称，自定义名称之间用空格隔开，每个语法表达式用分号结束")]),a._v(" "),s("h5",{attrs:{id:"举例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#举例"}},[a._v("#")]),a._v(" 举例：")]),a._v(" "),s("p",[a._v("int a = 1 + 2;")]),a._v(" "),s("p",[a._v("从package开始")]),a._v(" "),s("p",[a._v(".....")]),a._v(" "),s("p",[a._v("int 就是通过语法关键字判定的TOKEN:INT")]),a._v(" "),s("p",[a._v("int a之间通过空格隔开")]),a._v(" "),s("p",[a._v("a 就是自定义的变量被判定为TOKEN:IDENTIFIER")]),a._v(" "),s("p",[a._v("a =之间通过空格隔开(这时有的小伙伴就会说了，"),s("strong",[a._v("int a=b+c;这句话也不报错啊")]),a._v("，对的，大多数时候，这种不用空格分开确实能够编译，"),s("strong",[a._v("这是因为java指出声明变量的时候必须以字母、下划线或者美元符开头，当JavacParser读完a去读=的时候就直到这个=不属于变量了")]),a._v(")将=判定为TOKEN:EQ")]),a._v(" "),s("p",[a._v("1被判定为TOKEN:INTLITERAL")]),a._v(" "),s("p",[a._v(".....")]),a._v(" "),s("p",[a._v("将;识别为TOKEN:SEMI")]),a._v(" "),s("p",[a._v(".....")]),a._v(" "),s("p",[a._v("最后读取到类结束，也就是}被判定为TOKEN:RBRACE")]),a._v(" "),s("h3",{attrs:{id:"_2-语法分析器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-语法分析器"}},[a._v("#")]),a._v(" 2.语法分析器：")]),a._v(" "),s("p",[a._v("刚才，词法解析器已经将Java源文件解析成了Token流。")]),a._v(" "),s("p",[a._v("现在，语法解析器就要将Token流组建成更加结构化的语法树。也就是将这些Token流中的单词装成一句话，完整的语句。")]),a._v(" "),s("h4",{attrs:{id:"_2-1作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1作用"}},[a._v("#")]),a._v(" 2.1作用")]),a._v(" "),s("p",[a._v("将进行词法分析后形成的Token流中的一个个Token组成一句句话，检查这一句句话是不是符合Java语言规范。")]),a._v(" "),s("h4",{attrs:{id:"_2-2语法分析三部分"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2语法分析三部分"}},[a._v("#")]),a._v(" 2.2语法分析三部分")]),a._v(" "),s("ul",[s("li",[a._v("package")]),a._v(" "),s("li",[a._v("import")]),a._v(" "),s("li",[a._v("类（包含class、interface、enum），一下提到的类泛指这三类，并不单单是指class")])]),a._v(" "),s("h4",{attrs:{id:"_2-3所用类库"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3所用类库"}},[a._v("#")]),a._v(" 2.3所用类库")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("com.sun.tools.javac.tree.TreeMaker  所有语法节点都是由它生成的，根据Name对象构建一个语法节点")])]),a._v(" "),s("li",[s("p",[a._v("com.sun.tools.javac.tree.JCTree$JCIf   所有的节点都会继承jctree和实现＊＊tree，譬如 JCIf extends JCTree.JCStatement implements IfTree")])]),a._v(" "),s("li",[s("p",[a._v("com.sun.tools.javac.tree.JCTree的三个属性")]),a._v(" "),s("ul",[s("li",[s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("Tree tag:每个语法节点都会以整数的形式表示，下一个节点在上一个节点上加1；\n复制代码\n")])])])]),a._v(" "),s("li",[s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("pos：也是一个整数，它存储的是这个语法节点在源代码中的起始位置，一个文件的位置是0，而－1表示不存在\n复制代码\n")])])])]),a._v(" "),s("li",[s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("type：它代表的是这个节点是什么java类型，如int，float，还是string等\n复制代码\n")])])])])])])]),a._v(" "),s("h4",{attrs:{id:"_2-4-举例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-举例"}},[a._v("#")]),a._v(" 2.4 举例")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("package compile;\n\n/**\n * 语法\n */\npublic class Yufa {\n    int a;\n    private int c = a + 1;\n    \n    //getter\n    public int getC() {\n        return c;\n    }\n    //setter\n    public void setC(int c) {\n        this.c = c;\n    }\n}\n复制代码\n")])])]),s("p",[s("img",{attrs:{src:n(281),alt:"image"}})]),a._v(" "),s("ul",[s("li",[a._v("每一个包package下的所有类都会放在一个JCCompilationUnit节点下，在该节点下包含：package语法树（作为pid）、各个类的语法树")]),a._v(" "),s("li",[a._v("每一个从JCClassDecl发出的分支都是一个完整的代码块，上述是四个分支，对应我们代码中的两行属性操作语句和两个方法块代码块，这样其实就完成了语法分析器的作用：将一个个Token单词组成了一句句话（或者说成一句句代码块）")]),a._v(" "),s("li",[a._v("在上述的语法树部分，对于属性操作部分是完整的，但是对于两个方法块，省略了一些语法节点，例如：方法修饰符public、方法返回类型、方法参数。")])]),a._v(" "),s("blockquote",[s("p",[a._v("注1：若类中有import关键字则途中还有import的语法节点")])]),a._v(" "),s("blockquote",[s("p",[a._v("注2：所有语法节点的生成都是在TreeMaker类中完成的")])]),a._v(" "),s("h3",{attrs:{id:"_3-语义分析器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-语义分析器"}},[a._v("#")]),a._v(" 3.语义分析器")]),a._v(" "),s("h4",{attrs:{id:"_3-1作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-1作用"}},[a._v("#")]),a._v(" 3.1作用")]),a._v(" "),s("p",[a._v("将语法树转化为注解语法树，即在这颗语法树上做一些处理")]),a._v(" "),s("h4",{attrs:{id:"_3-2步骤"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2步骤"}},[a._v("#")]),a._v(" 3.2步骤")]),a._v(" "),s("ul",[s("li",[a._v("给类添加默认构造函数(由com.sun.tools.javac.comp.Enter类完成)")]),a._v(" "),s("li",[a._v("处理注解(由com.sun.tools.javac.processing.JavacProcessingEnvironment类完成)")]),a._v(" "),s("li",[a._v("检查语义的合法性并进行逻辑判断(由com.sun.tools.javac.comp.Attr完成)\n"),s("ul",[s("li",[a._v("变量的类型是否匹配")]),a._v(" "),s("li",[a._v("变量在使用前是否初始化")]),a._v(" "),s("li",[a._v("能够推导出泛型方法的参数类型")]),a._v(" "),s("li",[a._v("字符串常量合并")])])]),a._v(" "),s("li",[a._v("数据流分析(由com.sun.tools.javac.comp.Flow类完成)\n"),s("ul",[s("li",[a._v("检验变量是否被正确赋值（eg.有返回值的方法必须确定有返回值）")]),a._v(" "),s("li",[a._v("保证final变量不会被重复修饰")]),a._v(" "),s("li",[a._v("确定方法的返回值类型")]),a._v(" "),s("li",[a._v("所有的检查型异常是否抛出或捕获")]),a._v(" "),s("li",[a._v("所有的语句都要被执行到（return后边的语句就不会被执行到，除了finally块儿）")])])]),a._v(" "),s("li",[a._v("对语法树进行语义分析(由com.sun.tools.javac.comp.Flow执行)\n"),s("ul",[s("li",[a._v("去掉无用的代码，如只有永假的if代码块")]),a._v(" "),s("li",[a._v("变量的自动转换，如将int自动包装为Integer类型")]),a._v(" "),s("li",[a._v("去除语法糖，将foreach的形式转化为更简单的for循环")])])])]),a._v(" "),s("p",[a._v("最终，生成了注解语法树")]),a._v(" "),s("h4",{attrs:{id:"_3-3所用类库"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-3所用类库"}},[a._v("#")]),a._v(" 3.3所用类库")]),a._v(" "),s("ul",[s("li",[a._v("com.sun.tools.javac.comp.Check，它用来辅助Attr类检查语法树中变量类型是否正确，如方法返回值是否和接收的引用值类型匹配")]),a._v(" "),s("li",[a._v("com.sun.tools.javac.comp.Resolve，用来检查变量，方法或者类的访问是否合法，变量是否是静态变量")]),a._v(" "),s("li",[a._v("com.sun.tools.javac.comp.ConstFold，将一个字符串常量中的多个字符合并成一个字符串")]),a._v(" "),s("li",[a._v("com.sun.tools.javac.comp.Infer，帮助推导泛型方法的参数类型")])]),a._v(" "),s("h4",{attrs:{id:"_3-4举例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-4举例"}},[a._v("#")]),a._v(" 3.4举例")]),a._v(" "),s("p",[a._v("变量自动转化")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("public class Yuyi{\n    public static void main(String agrs[]){\n        Integer i = 1;\n        Long l = i + 2L;\n        System.out.println(l);\n    }\n}\n//经过自动转换后\npublic class Yuyi{\n    public Yuyi(){\n        super();\n    }\n    public static void main(String agrs[]){\n        Integer i = Integer.valueOf(1);\n        Long l = Long.valueOf(i.intValue() + 2L);\n        System.out.println(l);\n    }\n}\n复制代码\n")])])]),s("p",[a._v("解除语法糖")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("public class Yuyi{\n    public static void main(String agrs[]){\n        int[] array = {1,2,3};\n        for (int i : array){\n            System.out.println(i);\n        }\n    }\n}\n//解除语法糖后\npublic class Yuyi{\n    public Yuyi(){\n        super();\n    }\n    public static void main(String agrs[]){\n        int[] arrays = {1,2,3};\n        for (int[] arr$ = array,len$=arr$.length,i$=0; i$<len$; ++i$){\n            int i = arr$[i$];\n            {\n                System.out.println(i);\n            }\n        }\n    }\n}\n复制代码\n")])])]),s("p",[a._v("内部类解析")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('public class Yuyi{\n    public static void main(String agrs[]){\n        Inner inner = new Inner();\n        inner.print();\n    }\n    class Inner{\n        public void print(){\n            System.out.println("Yuyi$Inner.print");\n        }\n    }\n}\n//转化后的代码如下\npublic class Yuyi{\n    public Yuyi(){\n        super();\n    }\n    public static void main(String agrs[]){\n        Yuyi$Inner inner = new Yuyi$Inner(this);\n        inner.print();\n    }\n    {\n    }\n}\nclass Yuyi$Inner{\n    /*synthetic*/ final Yuyi this$0;\n    \n    Yuyi$Inner(/*synthetic*/final Yuyi this$0){\n        this.this$0 = this$0;\n        super();\n    }\n    \n    public void print(){\n        System.out.println("Yuyi$Inner.print");\n    }\n}\n\n复制代码\n')])])]),s("h3",{attrs:{id:"_4-代码生成器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-代码生成器"}},[a._v("#")]),a._v(" 4.代码生成器")]),a._v(" "),s("h4",{attrs:{id:"_4-1作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-1作用"}},[a._v("#")]),a._v(" 4.1作用")]),a._v(" "),s("p",[a._v("生成语法树后，接下来Javac会调用com.sun.tools.javac.jvm.Gen类遍历语法树，生成Java字节码")]),a._v(" "),s("h4",{attrs:{id:"_4-2步骤"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-2步骤"}},[a._v("#")]),a._v(" 4.2步骤")]),a._v(" "),s("ul",[s("li",[a._v("将java方法中代码块转化为符合JVM语法的命令形式，JVM的操作都是基于栈的，所有的操作都必须经过出栈和进栈来完成")]),a._v(" "),s("li",[a._v("按照JVM的文件组织格式将字节码输出到以class为拓展名的文件中")])]),a._v(" "),s("h4",{attrs:{id:"_4-3所用类库"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-3所用类库"}},[a._v("#")]),a._v(" 4.3所用类库")]),a._v(" "),s("ul",[s("li",[a._v("com.sun.tools.javac.jvm.Gen类，用来遍历语法树，生成最终Java字节码")]),a._v(" "),s("li",[a._v("com.sun.tools.javac.jvm.Items，辅助gen，这个类表示任何可寻址的操作项，这些操作项都可以作为一个单位出现在操作栈上")]),a._v(" "),s("li",[a._v("com.sun.tools.javac.jvm.Code，辅助gen，存储生成的字节码，并提供一些能够映射操作码的方法")])])])}),[],!1,null,null,null);t.default=e.exports}}]);