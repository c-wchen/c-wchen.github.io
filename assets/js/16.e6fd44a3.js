(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{290:function(t,i,n){t.exports=n.p+"assets/img/image-20201023150005632-163932642148720.122e68a8.png"},291:function(t,i,n){t.exports=n.p+"assets/img/image-20201023150105480.a3ca5749.png"},292:function(t,i,n){t.exports=n.p+"assets/img/image-20201023150157982.80bb544a.png"},468:function(t,i,n){"use strict";n.r(i);var s=n(13),a=Object(s.a)({},(function(){var t=this,i=t.$createElement,s=t._self._c||i;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"linux-io-模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#linux-io-模型"}},[t._v("#")]),t._v(" Linux IO 模型")]),t._v(" "),s("ol",[s("li",[t._v("阻塞（Blocking IO）：调用者未返回结结果之前客户端线程会被挂起，此时线程不可被CPU调度，线程暂停运行")]),t._v(" "),s("li",[t._v("非阻塞（Non-Blocking IO）： 在服务端返回之前，函数不会阻塞调用端线程，而是立即返回")]),t._v(" "),s("li",[t._v("同步（Sync IO）：调用端一直等待服务端响应（主动询问服务端是否完成）")]),t._v(" "),s("li",[t._v("异步 （Async IO）： 调用端调用之后就会返回，服务端通过通知机制或者回调函数通知客户端（被动接受）")])]),t._v(" "),s("h2",{attrs:{id:"图解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#图解"}},[t._v("#")]),t._v(" 图解")]),t._v(" "),s("ol",[s("li",[t._v("同步阻塞IO")])]),t._v(" "),s("p",[s("img",{attrs:{src:n(290),alt:"image-20201023150005632"}})]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("同步非阻塞IO")])]),t._v(" "),s("p",[s("img",{attrs:{src:n(291),alt:"image-20201023150105480"}})]),t._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[t._v("多路复用")])]),t._v(" "),s("p",[s("img",{attrs:{src:n(292),alt:"image-20201023150157982"}})]),t._v(" "),s("h2",{attrs:{id:"同步和异步io"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#同步和异步io"}},[t._v("#")]),t._v(" 同步和异步IO")]),t._v(" "),s("ol",[s("li",[t._v("Synchronous IO\n"),s("ul",[s("li",[t._v("blocking IO")]),t._v(" "),s("li",[t._v("non-blocking IO")]),t._v(" "),s("li",[t._v("IO-multiplexing")]),t._v(" "),s("li",[t._v("signal IO")])])]),t._v(" "),s("li",[t._v("Asynchronous IO\n"),s("ul",[s("li",[t._v("Linux（AIO）")]),t._v(" "),s("li",[t._v("winodws（IOCP）")])])])]),t._v(" "),s("p",[t._v("同步IO和异步IO的区别")]),t._v(" "),s("p",[t._v("两者的区别就在于synchronous IO做IO operation的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。注意到non-blocking IO会一直轮询(polling)，这个过程是没有阻塞的，但是recvfrom阶段blocking IO,non-blocking IO和IO multiplexing都是阻塞的。 而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。")]),t._v(" "),s("h2",{attrs:{id:"参考链接"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考链接"}},[t._v("#")]),t._v(" 参考链接")]),t._v(" "),s("p",[t._v("https://juejin.im/post/6844903782094995470")])])}),[],!1,null,null,null);i.default=a.exports}}]);