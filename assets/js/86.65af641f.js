(window.webpackJsonp=window.webpackJsonp||[]).push([[86],{404:function(l,v,_){"use strict";_.r(v);var i=_(13),t=Object(i.a)({},(function(){var l=this,v=l.$createElement,_=l._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":l.$parent.slotKey}},[_("ol",[_("li",[_("p",[l._v("选择排序")]),l._v(" "),_("ul",[_("li",[l._v("简单选择排序")]),l._v(" "),_("li",[l._v("堆排序")])])]),l._v(" "),_("li",[_("p",[l._v("插入排序")]),l._v(" "),_("ul",[_("li",[l._v("简单插入排序")]),l._v(" "),_("li",[l._v("希尔排序\n"),_("ul",[_("li",[l._v("不稳定排序， 选取不同增量进行排序时，可能导致数值相同的两个元素位置发生变化")])])])])]),l._v(" "),_("li",[_("p",[l._v("交换排序")]),l._v(" "),_("ul",[_("li",[l._v("冒泡排序")]),l._v(" "),_("li",[l._v("快速排序\n"),_("ul",[_("li",[l._v("在序列中找一个划分值，通过一趟排序将"),_("strong",[l._v("未排序的序列")]),l._v("排序成 独立的两个部分，其中左边部分序列都比划分值小，右边部分的序列比划分值大，此时划分值的位置已确认，然后再对这两个序列按照同样的方法进行排序，从而达到整个序列都有序的目的。")])])])])]),l._v(" "),_("li",[_("p",[l._v("归并排序")])]),l._v(" "),_("li",[_("p",[l._v("基数排序")]),l._v(" "),_("ul",[_("li",[l._v("桶排序")]),l._v(" "),_("li",[l._v("基数排序")])])]),l._v(" "),_("li",[_("p",[l._v("外部排序")])])])])}),[],!1,null,null,null);v.default=t.exports}}]);