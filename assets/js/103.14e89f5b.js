(window.webpackJsonp=window.webpackJsonp||[]).push([[103],{426:function(v,t,a){"use strict";a.r(t);var _=a(13),r=Object(_.a)({},(function(){var v=this,t=v.$createElement,a=v._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("p",[v._v("前端编译主要指与源语言有关但与目标机无关的部分，包括词法分析、语法分析、语义分析与中间代码生成。Javac是一种编译器，能"),a("strong",[v._v("将一种语言规范转化成另外一种语言规范，通常编译器都是将便于人理解的语言规范转化成机器容易理解的语言规范")]),v._v("，很多IDE，如eclipse，idea等，都内置了前端编译器。主要功能就是把.java代码转换成.class代码。")]),v._v(" "),a("h3",{attrs:{id:"编译阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#编译阶段"}},[v._v("#")]),v._v(" 编译阶段")]),v._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/9/29/16d7cd03af244662?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"img"}})]),v._v(" "),a("h4",{attrs:{id:"解析和填充符号表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解析和填充符号表"}},[v._v("#")]),v._v(" 解析和填充符号表")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("解析：词法分析 + 语法分析")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("词法分析： 源代码生成token序列")]),v._v(" "),a("p",[v._v("词法分析阶段是编译过程的第一个阶段。这个阶段的任务是从左到右一个字符一个字符地读入源程序，将字符序列转换为标记（token）序列的过程。这里的标记是一个字符串，是构成源代码的最小单位。在这个过程中，词法分析器还会对标记进行分类。")]),v._v(" "),a("p",[v._v("词法分析器通常不会关心标记之间的关系（属于语法分析的范畴），举例来说：词法分析器能够将括号识别为标记，但并不保证括号是否匹配。(转换源代码的关键字、标识符、操作符为token序列的过程)")]),v._v(" "),a("ul",[a("li",[v._v("java关键字：public, static, final, String, int等等；")]),v._v(" "),a("li",[v._v("自定义的名称：包名，类名，方法名和变量名；")]),v._v(" "),a("li",[v._v("运算符或者逻辑运算符等符号：+、-、*、/、&&，|| 等等。")])])]),v._v(" "),a("li",[a("p",[v._v("语法分析： 生成抽象树 AST（abstract syntax tree）是一种用来描述代码语法结构的树型表示方法， 语法树的每一个节点都代表着程序代码的一个语法结构， 例如包、类、修饰符、运算符、接口、返回值甚至代码注释都是一个语法结构 "),a("code",[v._v("com.sun.tools.javac.tree")])])])])]),v._v(" "),a("li",[a("p",[v._v("填充符号表")]),v._v(" "),a("p",[v._v("符号表是由一组符号地址和符号信息构成的表格，可以将它想象成哈希表中的K-V值对的形式（符号表不一定是哈希表实现，可以使有序符号表，树状符号表、栈结构符号表等）。符号表中所登记的信息在编译的不同阶段都要用到，在语义分析中，符号表所登记的内容将用于语义检查（如检查一个名字的使用和原先的说明是否一致）和产生中间代码。在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的依据")]),v._v(" "),a("p",[v._v("符号表： 符号表（Symbol Table）是由一组符号地址和符号信息构成的表格，读者可以把它想象成哈希表中K-V值对的形式（实际上符号表不一定是哈希表实现，可以是有序符号表、树状符号表、栈结构符号表等）")])])]),v._v(" "),a("h4",{attrs:{id:"语义分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#语义分析"}},[v._v("#")]),v._v(" 语义分析")]),v._v(" "),a("p",[v._v("​\t语义分析的主要任务是对结构正确的源程序进行上下文有关性质的审查，过程分为标注检查和数据及控制流分析两个步骤：")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("标注检查")]),v._v(" "),a("p",[v._v("检查语义合法性、进行逻辑判断，如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等；")])]),v._v(" "),a("li",[a("p",[v._v("数据及控制流分析")]),v._v(" "),a("p",[v._v("在Javac的源码中，数据及控制流分析的入口是图中的flow()，由com.sun.tools.javac.comp.Flow类来完成，作用是对程序上下文逻辑更进一步的验证，检查局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。")]),v._v(" "),a("p",[v._v("注解处理")]),v._v(" "),a("p",[v._v("提供了一组插入式注解处理器的标准API在编译期间对注解进行处理，我们可以把它看作是一组编译器的插件，在这些插件里面，可以读取，修改，添加抽象语法树中的任意元素。")]),v._v(" "),a("p",[v._v("解语法糖")]),v._v(" "),a("p",[v._v("语法糖（Syntactic Sugar），也称糖衣语法，指在计算机语言中添加的某种语法，Java中最常用的语法糖主要是的泛型擦除、变长参数、自动装箱/拆箱、条件编译等，解语法糖就是还原回简单的基础语法结构。")]),v._v(" "),a("ol",[a("li",[v._v("switch 支持 String 与枚举")]),v._v(" "),a("li",[v._v("泛型")]),v._v(" "),a("li",[v._v("自动装箱与拆箱")]),v._v(" "),a("li",[v._v("方法变长参数")]),v._v(" "),a("li",[v._v("枚举")]),v._v(" "),a("li",[v._v("内部类")]),v._v(" "),a("li",[v._v("条件编译")]),v._v(" "),a("li",[v._v("断言")]),v._v(" "),a("li",[v._v("数值字面量")]),v._v(" "),a("li",[v._v("for-each")]),v._v(" "),a("li",[v._v("try-with-resource")]),v._v(" "),a("li",[v._v("Lambda表达式")])])])]),v._v(" "),a("h4",{attrs:{id:"字节码生成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字节码生成"}},[v._v("#")]),v._v(" 字节码生成")]),v._v(" "),a("p",[v._v("生成语法树后，接下来Javac会调用com.sun.tools.javac.jvm.Gen类遍历语法树，生成Java字节码")]),v._v(" "),a("h3",{attrs:{id:"参考文献"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考文献"}},[v._v("#")]),v._v(" 参考文献")]),v._v(" "),a("p",[v._v("[基于Java实现的词法分析程序](https://www.write-b\tug.com/article/1258.html)")]),v._v(" "),a("p",[a("a",{attrs:{href:"https://zhuanlan.51cto.com/art/201905/596386.htm",target:"_blank",rel:"noopener noreferrer"}},[v._v("不了解这12个语法糖，别说你会Java"),a("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=r.exports}}]);